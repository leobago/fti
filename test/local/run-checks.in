#!/usr/bin/env bash
#
#  @file   run-checks.sh
#  @author Kai Keller (kellekai@gmx.de)
#  @date   June, 2017
#  @brief  FTI testing program.
#
#    The program may test the correct behaviour for checkpoint
#    and restart for all configurations. The recovered data is also
#    tested upon correct data fields.
#
#  Hit ./run-checks.sh -h for info
#
TIMEOUT=30
DFLAG=1
CFLAG=1
PROCS=16
diffSize=0
verbose=0
eraseFiles=0
corruptFiles=0
FAILED=0
SUCCEED=0
FAULTY=0
testFailed=0
display_usage() {
cat <<EOF
Usage: ./run-checks.sh [options]

-h|--help           shows this help.

-e|--erase-files    delete files before recovery
-d|--diff-size      use different sizes for checkpoint files
-c|--corrupt-files  corrupt files before recovery

Default (no options):

Checkpoint and restart for all levels with configurations:

HEAD | KEEP | L2 INLINE | L3 INLINE | L4 INLINE

0      0      1           1           1 (L1, L2, L3, L4)
0      1      1           1           1 (L1, L2, L3, L4)
1      0      1           1           1 (L1, L2, L3, L4)
1      1      1           1           1 (L1, L2, L3, L4)
1      0      0           1           1 (L2)
1      1      0           1           1 (L2)
1      0      1           0           1 (L3)
1      1      1           0           1 (L3)
1      0      1           1           0 (L4)
1      1      1           1           0 (L4)

-> 22 tests

If *erased-files* is set, L2 and L3 have 4 additional tests for cases with Keep=0 ( 24 tests ):

    - 2 checkpoint files in non-consecutive nodes are deleted before recovery
    - 2 partner/encoded files in non-consecutive nodes are deleted before recovery
    - 2 consecutive nodes are deleted before recovery
    - 2 non-consecutive nodes are deleted before recovery

L1 and L4 have one additional tests in cases with keep=0 ( 5 tests ):

    - 1 checkpoint file is deleted

Also after the Flush to the PFS for the Cases Head=0 and Head=1 one checkpoint file on the PFS is deleted before the recovery ( 2 tests ).

-> 31 additional tests

If *corrupt-files* is set, L2 and L3 have 2 additional tests for cases with Keep=0 ( 12 tests ):

    - 2 checkpoint files in non-consecutive nodes are corrupted before recovery
    - 2 partner/encoded files in non-consecutive nodes are corrupted before recovery

L1 and L4 have one additional tests in cases with keep=0 ( 5 tests ):

    - 1 checkpoint file is corrupted

Also after the Flush to the PFS for the Cases Head=0 and Head=1 one checkpoint file on the PFS is corrupted before the recovery ( 2 tests ).

-> 19 additional tests

if -e and -c is passed, there will be in total 72 tests.

If *diff-size* is set, the checkpoint files have different sizes.
EOF
}
while [[ $# -gt 0 ]]
do
key="$1"

case $key in
    -d|--diff-size)
    diffSize=1
    echo "[OPTION] Set different checkpoint sizes -> TRUE"
    ;;
    -v|--verbose)
    verbose=1
    echo "[OPTION] Set verbose mode -> TRUE"
    ;;
    -e|--erase-files)
    eraseFiles=1
    echo "[OPTION] Set erase checkpoint files -> TRUE"
    ;;
    -c|--corrupt-files)
    corruptFiles=1
    echo "[OPTION] Set corrupt checkpoint files -> TRUE"
    ;;
    -t|--set-timeout)
    if [[ $2 -lt "10" ]] || [[ $2 == -* ]]; then
        echo -e "Wrong argument for timeout: "$2
        echo -e "usage: [command] -t <integer -ge 10>"
        exit 0
    fi
    TIMEOUT="$2"
    echo "[OPTION] Set timeout -> "$TIMEOUT
    shift
    ;;
    -h|--help)
    display_usage
    exit 0
    ;;
esac
shift # past argument or value
done
#							 #
# ---- HEADER CHECK LOG ---- #
#							 #
cat <<EOF > check.log
### FTI TEST FOR $PROCS PROCESSES ###
EOF
#							 #
# ---- HEADER FAULTY LOG ---- #
#							 #
cat <<EOF > failed.log
### FAILED TESTS FOR $PROCS PROCESSES ###
EOF
#							   		    #
# ---- CONFIGURATION FILE TEMPLATE ---- #
#								        #
cat <<EOF >TMPLT
[basic]
head                           = 0
node_size                      = 4
ckpt_dir                       = Local
glbl_dir                       = Global
meta_dir                       = Meta
ckpt_io                        = 1
ckpt_l1                        = 0
ckpt_l2                        = 0
ckpt_l3                        = 0
ckpt_l4                        = 0
inline_l2                      = 1
inline_l3                      = 1
inline_l4                      = 1
keep_last_ckpt = 0
group_size                     = 4
verbosity                      = 2


[restart]
failure                        = 0
exec_id                        = 2017-05-18_13-35-26


[injection]
rank                           = 0
number                         = 0
position                       = 0
frequency                      = 0


[advanced]
block_size                     = 1024
transfer_size                  = 16
mpi_tag                        = 2612
local_test                     = 1
EOF
#								 #
# ---- FUNCTION DEFINITIONS ---- #
#								 #
should_not_fail() {
	if [ $1 = 0 ]; then
	    echo -e "\033[0;32mpassed\033[m"
		let SUCCEED=SUCCEED+1
	elif [ $1 = 255 ]; then
        echo -e "\033[0;31mfailed\033[m (FTI Abort)"
		let FAILED=FAILED+1
		testFailed=1
	elif [ $1 = 30 ]; then
		echo -e "\033[0;31mfailed\033[m (Checkpoint Data Corrupted!)"
		let FAILED=FAILED+1
		testFailed=1
	elif [ $1 = 20 ]; then
        echo -e "\033[0;31mfailed\033[m (Recovery Failed)"
		let FAILED=FAILED+1
		testFailed=1
	elif [ $1 = 143 ]; then
        echo -e "\033[0;31mfailed\033[m (Process Killed, Timeout!)"
		let FAILED=FAILED+1
		testFailed=1
	elif [ $1 = 40 ]; then
        echo -e "\033[0;31mfailed\033[m (Test Data Corrupted!)"
		let FAULTY=FAULTY+1
		testFailed=1
	else
		echo "Unknown exit status: "$1
		let FAULTY=FAULTY+1
		testFailed=1
	fi
}

should_fail() {
	if [ $1 = 255 ]; then
	    echo -e "\033[0;32mpassed\033[m (FTI Abort)"
		let SUCCEED=SUCCEED+1
	elif [ $1 = 0 ]; then
        echo -e "\033[0;31mfailed\033[m (Finalized Without Error!)"
		let FAILED=FAILED+1
		testFailed=1
	elif [ $1 = 30 ]; then
		echo -e "\033[0;31mfailed\033[m (Checkpoint Data Corrupted!)"
		let FAILED=FAILED+1
		testFailed=1
	elif [ $1 = 143 ]; then
        echo -e "\033[0;31mfailed\033[m (Process Killed, Timeout!)"
		let FAILED=FAILED+1
		testFailed=1
	elif [ $1 = 20 ]; then
        echo -e "\033[0;32mpassed\033[m (Recovery failed)"
		let SUCCEED=SUCCEED+1
	elif [ $1 = 40 ]; then
        echo -e "\033[0;31mfailed\033[m (Test Data Corrupted!)"
		let FAULTY=FAULTY+1
		testFailed=1
	else
		echo "Unknown exit status: "$1
		let FAULTY=FAULTY+1
		testFailed=1
	fi
}

check_return_val() {
	if [ $1 = 0 ]; then
	    echo -e "\033[0;32mpassed\033[m"
		let SUCCEED=SUCCEED+1
	elif [ $1 = 255 ]; then
        echo -e "\033[0;31mfailed\033[m"
		let FAILED=FAILED+1
		testFailed=1
    fi
}

set_inline() {
    case $1 in
        1)
            let l2=1
            let l3=1
            let l4=1
            ;;
        2)
            let l2=$2
            let l3=1
            let l4=1
            ;;
        3)
            let l2=1
            let l3=$2
            let l4=1
            ;;
        4)
            let l2=1
            let l3=1
            let l4=$2
            ;;
    esac
}
#						 #
# ---- TEST SCRIPTS ---- #
#	#
LEVEL=(1 2 3 4)
INLINE_L2=(0 1)
INLINE_L3=(0 1)
INLINE_L4=(0 1)
KEEP=(0 1)
IO_NAMES=(@IO_NAMES@)

#                     #
# ---- Check dCP ---- #
#                     #
echo -e "[ \033[1m*** Testing dCP: head=0 ***\033[m ]"
( set -x; bash checkDCP.sh 0 &>> check.log )
check_return_val $?
if [ $testFailed = 1 ]; then
    echo -e "dCP check (head=0) failed" >> failed.log
    testFailed=0
fi
echo -e "[ \033[1m*** Testing dCP: head=1 ***\033[m ]"
( set -x; bash checkDCP.sh 1 &>> check.log )
check_return_val $?
if [ $testFailed = 1 ]; then
    echo -e "dCP check (head=1) failed" >> failed.log
    testFailed=0
fi

for io in $(seq 1 @IO@); do
    let io_id=io-1
    awk -v var="$io" '$1 == "ckpt_io" {$3 = var}1' TMPLT > tmp; cp tmp TMPLT
    for keep in ${KEEP[*]}; do
        NAME="H0K"$keep"I111"
        #                  #
        # --- HEAD = 0 --- #
        #                  #
        for level in ${LEVEL[*]}; do
            awk -v var="$keep" '$1 == "keep_last_ckpt" {$3 = var}1' TMPLT > tmp; cp tmp $NAME
            echo -e "[ \033[1m*** Testing "${IO_NAMES[$io_id]}": L"$level", head=0, keep="$keep", inline=(1,1,1)... ***\033[m ]"
            if [ $keep -eq "1" ]; then
                #                  #
                # --- KEEP = 1 --- #
                #                  #
                ( set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                ### SETTING KEEP = 0 TO CLEAN DIRECTORY AFTER TEST
                awk '$1 == "keep_last_ckpt" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                should_not_fail $?
                if [ $testFailed = 1 ]; then
                    echo -e ${IO_NAMES[$io_id]}": L"$level", head=0, keep="$keep", inline=(1,1,1), should recover, ID: "$check_id >> failed.log
                    testFailed=0
                fi
                awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                if [ $eraseFiles = "1" ] && [ $DFLAG = "1" ]; then
                    awk '$1 == "keep_last_ckpt" {$3 = 1}1' $NAME > tmp; cp tmp $NAME; rm tmp
                    ( set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                    check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                    ### DELETE CHECKPOINT FILE
                    echo -e "[ \033[1mDeleting Checkpoint File...\033[m ]"
                    folder="Global/"$check_id"/l4"
                    filename=$(ls $folder | grep 'Rank\|mpiio\|sionlib' | head -n 1)
                    ( set -x; rm -rf $folder"/"$filename )
                    ### SETTING KEEP = 0 TO CLEAN DIRECTORY AFTER TEST
                    awk '$1 == "keep_last_ckpt" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                    ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                    should_fail $?
                    if [ $testFailed = 1 ]; then
                        echo -e ${IO_NAMES[$io_id]}": L"$level", head=0, keep="$keep", inline=(1,1,1), deleted flushed ckpt file on PFS, should not recover, ID: "$check_id >> failed.log
                        testFailed=0
                    fi
                    awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                    let DFLAG=2
                fi
#                if [ $corruptFiles = "1" ] && [ $CFLAG = "1" ]; then
#                    awk '$1 == "keep_last_ckpt" {$3 = 1}1' $NAME > tmp; cp tmp $NAME; rm tmp
#                    ( set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
#                    check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
#                    ### CORRUPT CHECKPOINT FILE
#                    echo -e "[ \033[1mCorrupting Checkpoint File...\033[m ]"
#                    folder="Global/"$check_id"/l4"
#                    filename=$(ls $folder | grep 'Rank\|mpiio\|sionlib' | head -n 1)
#                    ( set -x; printf "corruption" | dd conv=notrunc of=$folder"/"$filename bs=1 > /dev/null 2>&1 )
#                    ### SETTING KEEP = 0 TO CLEAN DIRECTORY AFTER TEST
#                    awk '$1 == "keep_last_ckpt" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
#                    ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
#                    should_fail $?
#                    if [ $testFailed = 1 ]; then
#                        echo -e ${IO_NAMES[$io_id]}": L"$level", head=0, keep="$keep", inline=(1,1,1), corrupted flushed ckpt file on PFS, should not recover, ID: "$check_id >> failed.log
#                        testFailed=0
#                    fi
#                    awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
#                    let CFLAG=2
#                fi
            fi
            if [ $keep -eq "0" ]; then
                #                  #
                # --- KEEP = 0 --- #
                #                  #
                ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                should_not_fail $?
                if [ $testFailed = 1 ]; then
                    echo -e ${IO_NAMES[$io_id]}": L"$level", head=0, keep="$keep", inline=(1,1,1), should recover, ID: "$check_id >> failed.log
                    testFailed=0
                fi
                awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                if [ $corruptFiles = "1" ]; then
                    if [ $level = 1 ]; then
                        ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                        check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                        ### CORRUPT Checkpoint FILES
                        echo -e "[ \033[1mCorrupting Checkpoint Files...\033[m ]"
                        folder="Local/node0/"$check_id"/l1"
                        filename=$(ls $folder | grep Rank | head -n 1)
                        ( set -x; printf "corruption" | dd conv=notrunc of=$folder"/"$filename bs=1 > /dev/null 2>&1 )
                        ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                        should_fail $?
                        if [ $testFailed = 1 ]; then
                            echo -e ${IO_NAMES[$io_id]}": L"$level", head=0, keep="$keep", inline=(1,1,1), corrupted L1 ckpt file, should not recover, ID: "$check_id >> failed.log
                            testFailed=0
                        fi
                        awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                    fi
                    if [ $level = 2 ]; then
                        ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                        check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                        ### CORRUPT Checkpoint FILES
                        echo -e "[ \033[1mCorrupting Checkpoint Files...\033[m ]"
                        folder="Local/node0/"$check_id"/l2"
                        filename=$(ls $folder | grep Rank | head -n 1)
                        ( set -x; printf "corruption" | dd conv=notrunc of=$folder"/"$filename bs=1 > /dev/null 2>&1 )
                        folder="Local/node2/"$check_id"/l2"
                        filename=$(ls $folder | grep Rank | head -n 1)
                        ( set -x; printf "corruption" | dd conv=notrunc of=$folder"/"$filename bs=1 > /dev/null 2>&1 )
                        ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                        should_not_fail $?
                        if [ $testFailed = 1 ]; then
                            echo -e ${IO_NAMES[$io_id]}": L"$level", head=0, keep="$keep", inline=(1,1,1), corrupted L2 ckpt files, should recover, ID: "$check_id >> failed.log
                            testFailed=0
                        fi
                        awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                        ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                        check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                        ### CORRUPT PARTNER FILES
                        echo -e "[ \033[1mCorrupting Partner Files...\033[m ]"
                        folder="Local/node0/"$check_id"/l2"
                        filename=$(ls $folder | grep Pcof | head -n 1)
                        ( set -x; printf "corruption" | dd conv=notrunc of=$folder"/"$filename bs=1 > /dev/null 2>&1 )
                        folder="Local/node2/"$check_id"/l2"
                        filename=$(ls $folder | grep Pcof | head -n 1)
                        ( set -x; printf "corruption" | dd conv=notrunc of=$folder"/"$filename bs=1 > /dev/null 2>&1 )
                        ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                        should_not_fail $?
                        if [ $testFailed = 1 ]; then
                            echo -e ${IO_NAMES[$io_id]}": L"$level", head=0, keep="$keep", inline=(1,1,1), corrupted L2 partner files, should recover, ID: "$check_id >> failed.log
                            testFailed=0
                        fi
                        awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                    fi
                    if [ $level = 3 ]; then
                        ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                        check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                        ### CORRUPT Checkpoint FILES
                        echo -e "[ \033[1mCorrupting Checkpoint Files...\033[m ]"
                        folder="Local/node0/"$check_id"/l3"
                        filename=$(ls $folder | grep Rank | head -n 1)
                        ( set -x; printf "corruption" | dd conv=notrunc of=$folder"/"$filename bs=1 > /dev/null 2>&1 )
                        folder="Local/node2/"$check_id"/l3"
                        filename=$(ls $folder | grep Rank | head -n 1)
                        ( set -x; printf "corruption" | dd conv=notrunc of=$folder"/"$filename bs=1 > /dev/null 2>&1 )
                        ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                        should_not_fail $?
                        if [ $testFailed = 1 ]; then
                            echo -e ${IO_NAMES[$io_id]}": L"$level", head=0, keep="$keep", inline=(1,1,1), corrupted L3 ckpt files, should recover, ID: "$check_id >> failed.log
                            testFailed=0
                        fi
                        awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                        ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                        check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                        ### CORRUPT PARTNER FILES
                        echo -e "[ \033[1mCorrupting Encoded Files...\033[m ]"
                        folder="Local/node0/"$check_id"/l3"
                        filename=$(ls $folder | grep Rsed | head -n 1)
                        ( set -x; printf "corruption" | dd conv=notrunc of=$folder"/"$filename bs=1 > /dev/null 2>&1 )
                        folder="Local/node2/"$check_id"/l3"
                        filename=$(ls $folder | grep Rsed | head -n 1)
                        ( set -x; printf "corruption" | dd conv=notrunc of=$folder"/"$filename bs=1 > /dev/null 2>&1 )
                        ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                        should_not_fail $?
                        if [ $testFailed = 1 ]; then
                            echo -e ${IO_NAMES[$io_id]}": L"$level", head=0, keep="$keep", inline=(1,1,1), corrupted L3 encoded files, should recover, ID: "$check_id >> failed.log
                            testFailed=0
                        fi
                        awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                    fi
#                    if [ $level = 4 ]; then
#                        ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
#                        check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
#                        ### CORRUPT Checkpoint FILES
#                        echo -e "[ \033[1mCorrupting Checkpoint Files...\033[m ]"
#                        folder="Global/"$check_id"/l4"
#                        filename=$(ls $folder | grep 'Rank\|mpiio\|sionlib' | head -n 1)
#                        ( set -x; printf "corruption" | dd conv=notrunc of=$folder"/"$filename bs=1 > /dev/null 2>&1 )
#                        ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
#                        should_fail $?
#                        if [ $testFailed = 1 ]; then
#                            echo -e ${IO_NAMES[$io_id]}": L"$level", head=0, keep="$keep", inline=(1,1,1), corrupted L4 ckpt file, should not recover, ID: "$check_id >> failed.log
#                            testFailed=0
#                        fi
#                        awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
#                    fi
                fi
                if [ $eraseFiles = "1" ]; then
                    if [ $level = 1 ]; then
                        ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                        check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                        ### DELETE CHECKPOINT FILE
                        echo -e "[ \033[1mDeleting Checkpoint File...\033[m ]"
                        folder="Local/node0/"$check_id"/l1"
                        filename=$(ls $folder | grep Rank | head -n 1)
                        ( set -x; rm -rf $folder"/"$filename )
                        ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                        should_fail $?
                        if [ $testFailed = 1 ]; then
                            echo -e ${IO_NAMES[$io_id]}": L"$level", head=0, keep="$keep", inline=(1,1,1), deleted L1 ckpt file, should not recover, ID: "$check_id >> failed.log
                            testFailed=0
                        fi
                        awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                    fi
                    if [ $level = 2 ]; then
                        ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                        check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                        ### DELETE Checkpoint FILES
                        echo -e "[ \033[1mDeleting Checkpoint Files...\033[m ]"
                        folder="Local/node0/"$check_id"/l2"
                        filename=$(ls $folder | grep Rank | head -n 1)
                        ( set -x; rm -rf $folder"/"$filename )
                        folder="Local/node2/"$check_id"/l2"
                        filename=$(ls $folder | grep Rank | head -n 1)
                        ( set -x; rm -rf $folder"/"$filename )
                        ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                        should_not_fail $?
                        if [ $testFailed = 1 ]; then
                            echo -e ${IO_NAMES[$io_id]}": L"$level", head=0, keep="$keep", inline=(1,1,1), deleted L2 ckpt files, should recover, ID: "$check_id >> failed.log
                            testFailed=0
                        fi
                        awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                        ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                        check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                        ### DELETE PARTNER FILES
                        echo -e "[ \033[1mDeleting Partner Files...\033[m ]"
                        folder="Local/node0/"$check_id"/l2"
                        filename=$(ls $folder | grep Pcof | head -n 1)
                        ( set -x; rm -rf $folder"/"$filename )
                        folder="Local/node2/"$check_id"/l2"
                        filename=$(ls $folder | grep Pcof | head -n 1)
                        ( set -x; rm -rf $folder"/"$filename )
                        ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                        should_not_fail $?
                        if [ $testFailed = 1 ]; then
                            echo -e ${IO_NAMES[$io_id]}": L"$level", head=0, keep="$keep", inline=(1,1,1), deleted L2 partner files, should recover, ID: "$check_id >> failed.log
                            testFailed=0
                        fi
                        awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                        ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                        check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                        ### DELETE NODES
                        echo -e "[ \033[1mDeleting Consecutive Nodes...\033[m ]"
                        ( set -x; rm -rf Local/node0 )
                        ( set -x; rm -rf Local/node1 )
                        ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                        should_fail $?
                        if [ $testFailed = 1 ]; then
                            echo -e ${IO_NAMES[$io_id]}": L"$level", head=0, keep="$keep", inline=(1,1,1), deleted two consecutive nodes, should not recover, ID: "$check_id >> failed.log
                            testFailed=0
                        fi
                        awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                        ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                        check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                        ### DELETE NODES
                        echo -e "[ \033[1mDeleting Non-Consecutive Nodes...\033[m ]"
                        ( set -x; rm -rf Local/node0 )
                        ( set -x; rm -rf Local/node2 )
                        ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                        should_not_fail $?
                        if [ $testFailed = 1 ]; then
                            echo -e ${IO_NAMES[$io_id]}": L"$level", head=0, keep="$keep", inline=(1,1,1), deleted two non-consecutive nodes, should recover, ID: "$check_id >> failed.log
                            testFailed=0
                        fi
                        awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                    fi
                    if [ $level = 3 ]; then
                        ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                        check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                        ### DELETE Checkpoint FILES
                        echo -e "[ \033[1mDeleting Checkpoint Files...\033[m ]"
                        folder="Local/node0/"$check_id"/l3"
                        filename=$(ls $folder | grep Rank | head -n 1)
                        ( set -x; rm -rf $folder"/"$filename )
                        folder="Local/node2/"$check_id"/l3"
                        filename=$(ls $folder | grep Rank | head -n 1)
                        ( set -x; rm -rf $folder"/"$filename )
                        ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                        should_not_fail $?
                        if [ $testFailed = 1 ]; then
                            echo -e ${IO_NAMES[$io_id]}": L"$level", head=0, keep="$keep", inline=(1,1,1), deleted L3 ckpt files, should recover, ID: "$check_id >> failed.log
                            testFailed=0
                        fi
                        awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                        ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                        check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                        ### DELETE ENCODED FILES
                        echo -e "[ \033[1mDeleting Encoded Files...\033[m ]"
                        folder="Local/node0/"$check_id"/l3"
                        filename=$(ls $folder | grep Rsed | head -n 1)
                        ( set -x; rm -rf $folder"/"$filename )
                        folder="Local/node2/"$check_id"/l3"
                        filename=$(ls $folder | grep Rsed | head -n 1)
                        ( set -x; rm -rf $folder"/"$filename )
                        ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                        should_not_fail $?
                        if [ $testFailed = 1 ]; then
                            echo -e ${IO_NAMES[$io_id]}": L"$level", head=0, keep="$keep", inline=(1,1,1), deleted L3 encoded files, should recover, ID: "$check_id >> failed.log
                            testFailed=0
                        fi
                        awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                        ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                        check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                        ### DELETE NODES
                        echo -e "[ \033[1mDeleting Consecutive Nodes...\033[m ]"
                        ( set -x; rm -rf Local/node0 )
                        ( set -x; rm -rf Local/node1 )
                        ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                        should_not_fail $?
                        if [ $testFailed = 1 ]; then
                            echo -e ${IO_NAMES[$io_id]}": L"$level", head=0, keep="$keep", inline=(1,1,1), deleted two consecutive nodes, should recover, ID: "$check_id >> failed.log
                            testFailed=0
                        fi
                        awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                        ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                        check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                        ### DELETE NODES
                        echo -e "[ \033[1mDeleting Non-Consecutive Nodes...\033[m ]"
                        ( set -x; rm -rf Local/node0 )
                        ( set -x; rm -rf Local/node2 )
                        ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                        should_not_fail $?
                        if [ $testFailed = 1 ]; then
                            echo -e ${IO_NAMES[$io_id]}": L"$level", head=0, keep="$keep", inline=(1,1,1), deleted two non-consecutive nodes, should recover, ID: "$check_id >> failed.log
                            testFailed=0
                        fi
                        awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                    fi
                    if [ $level = 4 ]; then
                        ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                        check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                        ### DELETE CHECKPOINT FILE
                        echo -e "[ \033[1mDeleting Checkpoint File...\033[m ]"
                        folder="Global/"$check_id"/l4"
                        filename=$(ls $folder | grep 'Rank\|mpiio\|sionlib' | head -n 1)
                        ( set -x; rm -rf $folder"/"$filename )
                        ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                        should_fail $?
                        if [ $testFailed = 1 ]; then
                            echo -e ${IO_NAMES[$io_id]}": L"$level", head=0, keep="$keep", inline=(1,1,1), deleted L4 ckpt file, should not recover, ID: "$check_id >> failed.log
                            testFailed=0
                        fi
                        awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                    fi
                fi
            fi
        done
        rm $NAME
    done
    for keep in ${KEEP[*]}; do
        for level in ${LEVEL[*]}; do
            for inline in 0 1; do
                if [ $inline -eq 1 ] || [[ $inline -eq 0 && $level -ne 1 ]]; then
                    set_inline $level $inline
                    NAME="H1K"$keep"I"$l2""$l3""$l4
                    #                  #
                    # --- HEAD = 1 --- #
                    #                  #
                    awk '$1 == "head" {$3 = 1}1' TMPLT > tmp; cp tmp TMPLT
                    awk -v var="$keep" '$1 == "keep_last_ckpt" {$3 = var}1' TMPLT > tmp; cp tmp TMPLT
                    awk -v var="$l2" '$1 == "inline_l2" {$3 = var}1' TMPLT > tmp; cp tmp TMPLT
                    awk -v var="$l3" '$1 == "inline_l3" {$3 = var}1' TMPLT > tmp; cp tmp TMPLT
                    awk -v var="$l4" '$1 == "inline_l4" {$3 = var}1' TMPLT > $NAME; rm tmp
                    echo -e "[ \033[1m*** Testing "${IO_NAMES[$io_id]}": L"$level", head=1, keep="$keep", inline=("$l2","$l3","$l4")... ***\033[m ]"
                    if [ $keep -eq "1" ]; then
                        ( set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                        check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                        ### SETTING KEEP = 0 TO CLEAN DIRECTORY AFTER TEST
                        awk '$1 == "keep_last_ckpt" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                        ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                        should_not_fail $?
                        if [ $testFailed = 1 ]; then
                            echo -e ${IO_NAMES[$io_id]}": L"$level", head=1, keep="$keep", inline=("$l2","$l3","$l4"), should recover, ID: "$check_id >> failed.log
                            testFailed=0
                        fi
                        awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                        if [ $eraseFiles = "1" ] && [ $DFLAG = "2" ]; then
                            awk '$1 == "keep_last_ckpt" {$3 = 1}1' $NAME > tmp; cp tmp $NAME; rm tmp
                            ( set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                            check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                            ### DELETE CHECKPOINT FILE
                            echo -e "[ \033[1mDeleting Checkpoint File...\033[m ]"
                            folder="Global/"$check_id"/l4"
                            filename=$(ls $folder | grep 'Rank\|mpiio\|sionlib' | head -n 1)
                            ( set -x; rm -rf $folder"/"$filename )
                            ### SETTING KEEP = 0 TO CLEAN DIRECTORY AFTER TEST
                            awk '$1 == "keep_last_ckpt" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                            ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                            should_fail $?
                            if [ $testFailed = 1 ]; then
                                echo -e ${IO_NAMES[$io_id]}": L"$level", head=1, keep="$keep", inline=("$l2","$l3","$l4"), deleted flushed ckpt file on PFS, should not recover, ID: "$check_id >> failed.log
                                testFailed=0
                            fi
                            awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                            let DFLAG=3
                        fi
#                        if [ $corruptFiles = "1" ] && [ $CFLAG = "2" ]; then
#                            awk '$1 == "keep_last_ckpt" {$3 = 1}1' $NAME > tmp; cp tmp $NAME; rm tmp
#                            ( set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
#                            check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
#                            ### CORRUPT CHECKPOINT FILE
#                            echo -e "[ \033[1mCorrupting Checkpoint File...\033[m ]"
#                            folder="Global/"$check_id"/l4"
#                            filename=$(ls $folder | grep 'Rank\|mpiio\|sionlib' | head -n 1)
#                            ( set -x; printf "corruption" | dd conv=notrunc of=$folder"/"$filename bs=1 > /dev/null 2>&1 )
#                            ### SETTING KEEP = 0 TO CLEAN DIRECTORY AFTER TEST
#                            awk '$1 == "keep_last_ckpt" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
#                            ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
#                            should_fail $?
#                            if [ $testFailed = 1 ]; then
#                                echo -e ${IO_NAMES[$io_id]}": L"$level", head=1, keep="$keep", inline=("$l2","$l3","$l4"), corrupted flushed ckpt file on PFS, should not recover, ID: "$check_id >> failed.log
#                                testFailed=0
#                            fi
#                            awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
#                            let CFLAG=3
#                        fi
                    fi
                    if [ $keep -eq "0" ]; then
                        ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                        check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                        ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                        should_not_fail $?
                        if [ $testFailed = 1 ]; then
                            echo -e ${IO_NAMES[$io_id]}": L"$level", head=1, keep="$keep", inline=("$l2","$l3","$l4"), should recover, ID: "$check_id >> failed.log
                            testFailed=0
                        fi
                        awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                        if [ $corruptFiles = "1" ]; then
                            if [ $level = 1 ]; then
                                ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                                check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                                ### CORRUPT Checkpoint FILES
                                echo -e "[ \033[1mCorrupting Checkpoint Files...\033[m ]"
                                folder="Local/node0/"$check_id"/l1"
                                filename=$(ls $folder | grep Rank | head -n 1)
                                ( set -x; printf "corruption" | dd conv=notrunc of=$folder"/"$filename bs=1 > /dev/null 2>&1 )
                                ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                                should_fail $?
                                if [ $testFailed = 1 ]; then
                                    echo -e ${IO_NAMES[$io_id]}": L"$level", head=1, keep="$keep", inline=("$l2","$l3","$l4"), corrupted L1 ckpt file, should not recover, ID: "$check_id >> failed.log
                                    testFailed=0
                                fi
                                awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                            fi
                            if [ $level = 2 ]; then
                                ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                                check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                                ### CORRUPT Checkpoint FILES
                                echo -e "[ \033[1mCorrupting Checkpoint Files...\033[m ]"
                                folder="Local/node0/"$check_id"/l2"
                                filename=$(ls $folder | grep Rank | head -n 1)
                                ( set -x; printf "corruption" | dd conv=notrunc of=$folder"/"$filename bs=1 > /dev/null 2>&1 )
                                folder="Local/node2/"$check_id"/l2"
                                filename=$(ls $folder | grep Rank | head -n 1)
                                ( set -x; printf "corruption" | dd conv=notrunc of=$folder"/"$filename bs=1 > /dev/null 2>&1 )
                                ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                                should_not_fail $?
                                if [ $testFailed = 1 ]; then
                                    echo -e ${IO_NAMES[$io_id]}": L"$level", head=1, keep="$keep", inline=("$l2","$l3","$l4"), corrupted L2 ckpt files, should recover, ID: "$check_id >> failed.log
                                    testFailed=0
                                fi
                                awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                                ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                                check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                                ### CORRUPT PARTNER FILES
                                echo -e "[ \033[1mCorrupting Partner Files...\033[m ]"
                                folder="Local/node0/"$check_id"/l2"
                                filename=$(ls $folder | grep Pcof | head -n 1)
                                ( set -x; printf "corruption" | dd conv=notrunc of=$folder"/"$filename bs=1 > /dev/null 2>&1 )
                                folder="Local/node2/"$check_id"/l2"
                                filename=$(ls $folder | grep Pcof | head -n 1)
                                ( set -x; printf "corruption" | dd conv=notrunc of=$folder"/"$filename bs=1 > /dev/null 2>&1 )
                                ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                                should_not_fail $?
                                if [ $testFailed = 1 ]; then
                                    echo -e ${IO_NAMES[$io_id]}": L"$level", head=1, keep="$keep", inline=("$l2","$l3","$l4"), corrupted L2 partner files, should recover, ID: "$check_id >> failed.log
                                    testFailed=0
                                fi
                                awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                            fi
                            if [ $level = 3 ]; then
                                ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                                check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                                ### CORRUPT Checkpoint FILES
                                echo -e "[ \033[1mCorrupting Checkpoint Files...\033[m ]"
                                folder="Local/node0/"$check_id"/l3"
                                filename=$(ls $folder | grep Rank | head -n 1)
                                ( set -x; printf "corruption" | dd conv=notrunc of=$folder"/"$filename bs=1 > /dev/null 2>&1 )
                                folder="Local/node2/"$check_id"/l3"
                                filename=$(ls $folder | grep Rank | head -n 1)
                                ( set -x; printf "corruption" | dd conv=notrunc of=$folder"/"$filename bs=1 > /dev/null 2>&1 )
                                ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                                should_not_fail $?
                                if [ $testFailed = 1 ]; then
                                    echo -e ${IO_NAMES[$io_id]}": L"$level", head=1, keep="$keep", inline=("$l2","$l3","$l4"), corrupted L3 ckpt files, should recover, ID: "$check_id >> failed.log
                                    testFailed=0
                                fi
                                awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                                ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                                check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                                ### CORRUPT PARTNER FILES
                                echo -e "[ \033[1mCorrupting Encoded Files...\033[m ]"
                                folder="Local/node0/"$check_id"/l3"
                                filename=$(ls $folder | grep Rsed | head -n 1)
                                ( set -x; printf "corruption" | dd conv=notrunc of=$folder"/"$filename bs=1 > /dev/null 2>&1 )
                                folder="Local/node2/"$check_id"/l3"
                                filename=$(ls $folder | grep Rsed | head -n 1)
                                ( set -x; printf "corruption" | dd conv=notrunc of=$folder"/"$filename bs=1 > /dev/null 2>&1 )
                                ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                                should_not_fail $?
                                if [ $testFailed = 1 ]; then
                                    echo -e ${IO_NAMES[$io_id]}": L"$level", head=1, keep="$keep", inline=("$l2","$l3","$l4"), corrupted L3 encoded files, should recover, ID: "$check_id >> failed.log
                                    testFailed=0
                                fi
                                awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                            fi
#                            if [ $level = 4 ]; then
#                                ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
#                                check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
#                                ### CORRUPT Checkpoint FILES
#                                echo -e "[ \033[1mCorrupting Checkpoint Files...\033[m ]"
#                                folder="Global/"$check_id"/l4"
#                                filename=$(ls $folder | grep 'Rank\|mpiio\|sionlib' | head -n 1)
#                                ( set -x; printf "corruption" | dd conv=notrunc of=$folder"/"$filename bs=1 > /dev/null 2>&1 )
#                                ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
#                                should_fail $?
#                                if [ $testFailed = 1 ]; then
#                                    echo -e ${IO_NAMES[$io_id]}": L"$level", head=1, keep="$keep", inline=("$l2","$l3","$l4"), corrupted L4 ckpt file, should not recover, ID: "$check_id >> failed.log
#                                    testFailed=0
#                                fi
#                                awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
#                            fi
                        fi
                        if [ $eraseFiles = "1" ]; then
                            if [ $level = 1 ]; then
                                ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                                check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                                ### DELETE CHECKPOINT FILE
                                echo -e "[ \033[1mDeleting Checkpoint File...\033[m ]"
                                folder="Local/node0/"$check_id"/l1"
                                filename=$(ls $folder | grep Rank | head -n 1)
                                ( set -x; rm -rf $folder"/"$filename )
                                ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                                should_fail $?
                                if [ $testFailed = 1 ]; then
                                    echo -e ${IO_NAMES[$io_id]}": L"$level", head=1, keep="$keep", inline=("$l2","$l3","$l4"), deleted L1 ckpt file, should not recover, ID: "$check_id >> failed.log
                                    testFailed=0
                                fi
                                awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                            fi
                            if [ $level = 2 ]; then
                                ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                                check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                                ### DELETE Checkpoint FILES
                                echo -e "[ \033[1mDeleting Checkpoint Files...\033[m ]"
                                folder="Local/node0/"$check_id"/l2"
                                filename=$(ls $folder | grep Rank | head -n 1)
                                ( set -x; rm -rf $folder"/"$filename )
                                folder="Local/node2/"$check_id"/l2"
                                filename=$(ls $folder | grep Rank | head -n 1)
                                ( set -x; rm -rf $folder"/"$filename )
                                ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                                should_not_fail $?
                                if [ $testFailed = 1 ]; then
                                    echo -e ${IO_NAMES[$io_id]}": L"$level", head=1, keep="$keep", inline=("$l2","$l3","$l4"), deleted L2 ckpt files, should recover, ID: "$check_id >> failed.log
                                    testFailed=0
                                fi
                                awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                                ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                                check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                                ### DELETE PARTNER FILES
                                echo -e "[ \033[1mDeleting Partner Files...\033[m ]"
                                folder="Local/node0/"$check_id"/l2"
                                filename=$(ls $folder | grep Pcof | head -n 1)
                                ( set -x; rm -rf $folder"/"$filename )
                                folder="Local/node2/"$check_id"/l2"
                                filename=$(ls $folder | grep Pcof | head -n 1)
                                ( set -x; rm -rf $folder"/"$filename )
                                ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                                should_not_fail $?
                                if [ $testFailed = 1 ]; then
                                    echo -e ${IO_NAMES[$io_id]}": L"$level", head=1, keep="$keep", inline=("$l2","$l3","$l4"), deleted L2 partner files, should recover, ID: "$check_id >> failed.log
                                    testFailed=0
                                fi
                                awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                                ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                                check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                                ### DELETE NODES
                                echo -e "[ \033[1mDeleting Consecutive Nodes...\033[m ]"
                                ( set -x; rm -rf Local/node0 )
                                ( set -x; rm -rf Local/node1 )
                                ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                                should_fail $?
                                if [ $testFailed = 1 ]; then
                                    echo -e ${IO_NAMES[$io_id]}": L"$level", head=1, keep="$keep", inline=("$l2","$l3","$l4"), deleted two consecutive nodes, should not recover, ID: "$check_id >> failed.log
                                    testFailed=0
                                fi
                                awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                                ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                                check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                                ### DELETE NODES
                                echo -e "[ \033[1mDeleting Non-Consecutive Nodes...\033[m ]"
                                ( set -x; rm -rf Local/node0 )
                                ( set -x; rm -rf Local/node2 )
                                ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                                should_not_fail $?
                                if [ $testFailed = 1 ]; then
                                    echo -e ${IO_NAMES[$io_id]}": L"$level", head=1, keep="$keep", inline=("$l2","$l3","$l4"), deleted two non-consecutive nodes, should recover, ID: "$check_id >> failed.log
                                    testFailed=0
                                fi
                                awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                            fi
                            if [ $level = 3 ]; then
                                ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                                check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                                ### DELETE Checkpoint FILES
                                echo -e "[ \033[1mDeleting Checkpoint Files...\033[m ]"
                                folder="Local/node0/"$check_id"/l3"
                                filename=$(ls $folder | grep Rank | head -n 1)
                                ( set -x; rm -rf $folder"/"$filename )
                                folder="Local/node2/"$check_id"/l3"
                                filename=$(ls $folder | grep Rank | head -n 1)
                                ( set -x; rm -rf $folder"/"$filename )
                                ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                                should_not_fail $?
                                if [ $testFailed = 1 ]; then
                                    echo -e ${IO_NAMES[$io_id]}": L"$level", head=1, keep="$keep", inline=("$l2","$l3","$l4"), deleted L3 ckpt files, should recover, ID: "$check_id >> failed.log
                                    testFailed=0
                                fi
                                awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                                ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                                check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                                ### DELETE ENCODED FILES
                                echo -e "[ \033[1mDeleting Encoded Files...\033[m ]"
                                folder="Local/node0/"$check_id"/l3"
                                filename=$(ls $folder | grep Rsed | head -n 1)
                                ( set -x; rm -rf $folder"/"$filename )
                                folder="Local/node2/"$check_id"/l3"
                                filename=$(ls $folder | grep Rsed | head -n 1)
                                ( set -x; rm -rf $folder"/"$filename )
                                ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                                should_not_fail $?
                                if [ $testFailed = 1 ]; then
                                    echo -e ${IO_NAMES[$io_id]}": L"$level", head=1, keep="$keep", inline=("$l2","$l3","$l4"), deleted L3 encoded files, should recover, ID: "$check_id >> failed.log
                                    testFailed=0
                                fi
                                awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                                ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                                check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                                ### DELETE NODES
                                echo -e "[ \033[1mDeleting Consecutive Nodes...\033[m ]"
                                ( set -x; rm -rf Local/node0 )
                                ( set -x; rm -rf Local/node1 )
                                ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                                should_not_fail $?
                                if [ $testFailed = 1 ]; then
                                    echo -e ${IO_NAMES[$io_id]}": L"$level", head=1, keep="$keep", inline=("$l2","$l3","$l4"), deleted two consecutive nodes, should recover, ID: "$check_id >> failed.log
                                    testFailed=0
                                fi
                                awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                                ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                                check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                                ### DELETE NODES
                                echo -e "[ \033[1mDeleting Non-Consecutive Nodes...\033[m ]"
                                ( set -x; rm -rf Local/node0 )
                                ( set -x; rm -rf Local/node2 )
                                ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                                should_not_fail $?
                                if [ $testFailed = 1 ]; then
                                    echo -e ${IO_NAMES[$io_id]}": L"$level", head=1, keep="$keep", inline=("$l2","$l3","$l4"), deleted two non-consecutive nodes, should recover, ID: "$check_id >> failed.log
                                    testFailed=0
                                fi
                                awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                            fi
                            if [ $level = 4 ]; then
                                ( set -x; mpirun -n $PROCS ./check.exe $NAME 1 $level $diffSize &>> check.log )
                                check_id=$(awk '$1 == "exec_id" {print $3}' < $NAME)
                                ### DELETE CHECKPOINT FILE
                                echo -e "[ \033[1mDeleting Checkpoint File...\033[m ]"
                                folder="Global/"$check_id"/l4"
                                filename=$(ls $folder | grep 'Rank\|mpiio\|sionlib' | head -n 1)
                                ( set -x; rm -rf $folder"/"$filename )
                                ( cmdpid=$BASHPID; (sleep $TIMEOUT; kill $cmdpid > /dev/null 2>&1 ) & set -x; mpirun -n $PROCS ./check.exe $NAME 0 $level $diffSize &>> check.log )
                                should_fail $?
                                if [ $testFailed = 1 ]; then
                                    echo -e ${IO_NAMES[$io_id]}": L"$level", head=1, keep="$keep", inline=("$l2","$l3","$l4"), deleted L4 ckpt file, should not recover, ID: "$check_id >> failed.log
                                    testFailed=0
                                fi
                                awk '$1 == "failure" {$3 = 0}1' $NAME > tmp; cp tmp $NAME; rm tmp
                            fi
                        fi
                    fi
                fi
            done
        done
        rm $NAME
    done
    let DFLAG=1
    let CFLAG=1
done
rm -rf TMPLT Global/* Local/* Meta/* chk/*
pkill -f check.exe
echo "---SUMMARY---"
echo "PASSED: "$SUCCEED
echo "FAILED: "$FAILED
echo "FAULTY: "$FAULTY
cat failed.log
